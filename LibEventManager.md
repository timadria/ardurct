# Arduino library to manage events #
## Organisation ##
<img src='http://ardurct.googlecode.com/svn/images/ArduRCT_EventManager.png'><br>
<h2>Principle</h2>
At the begining of your file<br>
<ul><li>Define the EventManager<br>
In the setup()<br>
</li><li>Register the listeners<br>
</li><li>Register the handlers<br>
In the loop()<br>
</li><li>call manageEvents: this will call the handlers for the events created by the listeners.<br>
<ul><li>In most cases, your loop should only contain this function.<br>
</li><li>This function can be called as often as you want: it will only run when required.</li></ul></li></ul>

<h2>Example</h2>
<pre><code>#include &lt;ArduRCT_EventManager.h&gt;<br>
<br>
#define ON_BUTTON        3<br>
#define OFF_BUTTON       4<br>
#define MOMENTARY_BUTTON 5<br>
<br>
#define LED_PIN 13<br>
<br>
// define the eventManager<br>
ArduRCT_EventManager eventManager;<br>
<br>
void setup() {<br>
    // prepare the led output<br>
    pinMode(LED_PIN, OUTPUT);<br>
<br>
    // register some switches<br>
    eventManager.registerSwitch(new ArduRCT_Switch(ON_BUTTON));<br>
    eventManager.registerSwitch(new ArduRCT_Switch(OFF_BUTTON));<br>
    eventManager.registerSwitch(new ArduRCT_Switch(MOMENTARY_BUTTON));<br>
    <br>
    // register an EventHandler for the switches: handleButtons will be called for every EVENT_SWITCH<br>
    eventManager.registerEventHandler(new ArduRCT_EventHandler(EVENT_SWITCH, EVENT_ANY_VALUE, &amp;handleButtons));<br>
}<br>
<br>
void loop() {<br>
    eventManager.manageEvents();<br>
}<br>
<br>
int8_t handleButtons(uint8_t eventType, uint8_t buttonId) {<br>
    if (eventType == EVENT_SWITCH_PRESSED) {<br>
        if (buttonId == OFF_BUTTON) digitalWrite(13, LOW);            // if the off switch is pressed, switch off the led<br>
        else digitalWrite(LED_PIN, HIGH);                             // else if any other switch is pressed, switch it on<br>
    } else if (eventType == EVENT_SWITCH_RELEASED) {<br>
        if (buttonId == MOMENTARY_BUTTON) digitalWrite(LED_PIN, LOW); // switch off the led if the button is released<br>
    }<br>
    return EVENT_HANDLING_DONE;<br>
}<br>
</code></pre>

<h2>Listeners</h2>
<table><thead><th>Listener object</th><th>Hardware</th><th>Created if</th><th>Events generated</th></thead><tbody>
<tr><td>               </td><td>CPU     </td><td>The EventManager loop is entered</td><td>EVENT_SYSTEM_TICK</td></tr>
<tr><td>ArduRCT_RealTimeClock</td><td>CPU     </td><td>A time related event occurs</td><td>EVENT_TIME_SECOND<br>EVENT_TIME_MINUTE<br>EVENT_TIME_HOUR<br>EVENT_TIME_DAY<br>EVENT_TIME_MONTH<br>EVENT_TIME_YEAR<br>EVENT_TIME_ALARM</td></tr>
<tr><td>ArduRCT_Switch </td><td>Momentary closed switch</td><td>The switch is pressed or released</td><td>EVENT_SWITCH_PRESSED<br>EVENT_SWITCH_RELEASED<br>EVENT_SWITCH_REPEATING</td></tr>
<tr><td>ArduRCT_Encoder</td><td>Rotary encoder</td><td>The encoder is rotated</td><td>EVENT_ENCODER_DECREASE<br>EVENT_ENCODER_INCREASE</td></tr>
<tr><td>ArduRCT_TouchPanel</td><td>Touchpanel</td><td>The touchpanel is touched</td><td>EVENT_TOUCHPANEL_PRESSED<br>EVENT_TOUCHPANEL_DRAGGED<br>EVENT_TOUCHPANEL_RELEASED</td></tr>
<tr><td>ArduRCT_Analog </td><td>Analog port</td><td>The analog value changes</td><td>EVENT_ANALOG_DECREASE<br>EVENT_ANALOG_INCREASE</td></tr></tbody></table>

Switches, touchpanels and rotary encoders are automatically debounced.<br>
<br>
<h2>Handlers</h2>
An handler associates a callback with an event. The handlers are called in the order in which they are registered.<br>
If the handler returns EVENT_HANDLING_EXIT, the following handlers for the event are not called.<br>
<br>
The callback can be called by:<br>
<ul><li>An event such as the one generated by the source<br>
</li><li>A class of event such as EVENT_SYSTEM, EVENT_TIME, EVENT_SWITCH, EVENT_ENCODER, EVENT_TOUCHPANEL, EVENT_ANALOG<br>
</li><li>An event and an event value</li></ul>

The EVENT_SYSTEM_TICK handler is slighly apart: it can call a function every N tick.<br>
Beware that since the tick counter is 8 bit long, you should use powers of two.<br>
<pre><code>ArduRCT_EventHandler everyTickHandler(EVENT_SYSTEM_TICK, 1, &amp;function1);            // will call function1 every tick<br>
ArduRCT_EventHandler everyFourTickHandler(EVENT_SYSTEM_TICK, 4, &amp;function4);        // will call function4 every 4 ticks<br>
ArduRCT_EventHandler everySixtyFourTickHandler(EVENT_SYSTEM_TICK, 64, &amp;function64); // will call function64 every 64 ticks<br>
</code></pre>

<h2>Configuration</h2>
The time between two polls of the listeners can be adjusted in ArduRCT_Events.hpp:<br>
<pre><code>#define EVENT_MANAGER_CYCLE 25<br>
</code></pre>
The lower the value, the better the reactivity to events; but the less time each callback has to perform its task.<br>
If a callback hangs or takes very long to perform, the next loop can be delayed. So you can't rely on ticks to properly mark timing.<br>
A good balance is a value between 20 (better for rotary encoders) and 50 (ok for all other listeners).<br>
